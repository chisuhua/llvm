; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py

; The test cases check that the single float arguments won't be extended
; when passing to softfloat functions.
; RISCV backend using shouldExtendTypeInLibCall target hook to suppress
; the extension generation.

define float @fadd_s(float %a, float %b) nounwind {
  %1 = fadd float %a, %b
  ret float %1
}

define float @fsub_s(float %a, float %b) nounwind {
  %1 = fsub float %a, %b
  ret float %1
}

define float @fmul_s(float %a, float %b) nounwind {
  %1 = fmul float %a, %b
  ret float %1
}

define float @fdiv_s(float %a, float %b) nounwind {
  %1 = fdiv float %a, %b
  ret float %1
}

define i32 @feq_s(float %a, float %b) nounwind {
  %1 = fcmp oeq float %a, %b
  %2 = zext i1 %1 to i32
  ret i32 %2
}

define i32 @flt_s(float %a, float %b) nounwind {
  %1 = fcmp olt float %a, %b
  %2 = zext i1 %1 to i32
  ret i32 %2
}

define i32 @fle_s(float %a, float %b) nounwind {
  %1 = fcmp ole float %a, %b
  %2 = zext i1 %1 to i32
  ret i32 %2
}

define i32 @fcmp_ogt(float %a, float %b) nounwind {
  %1 = fcmp ogt float %a, %b
  %2 = zext i1 %1 to i32
  ret i32 %2
}

define i32 @fcmp_oge(float %a, float %b) nounwind {
  %1 = fcmp oge float %a, %b
  %2 = zext i1 %1 to i32
  ret i32 %2
}

define i32 @fcmp_ord(float %a, float %b) nounwind {
  %1 = fcmp ord float %a, %b
  %2 = zext i1 %1 to i32
  ret i32 %2
}

define i32 @fcmp_une(float %a, float %b) nounwind {
  %1 = fcmp une float %a, %b
  %2 = zext i1 %1 to i32
  ret i32 %2
}

define i32 @fcvt_w_s(float %a) nounwind {
  %1 = fptosi float %a to i32
  ret i32 %1
}

define i32 @fcvt_wu_s(float %a) nounwind {
  %1 = fptoui float %a to i32
  ret i32 %1
}

define float @fcvt_s_w(i32 %a) nounwind {
  %1 = sitofp i32 %a to float
  ret float %1
}

define float @fcvt_s_wu(i32 %a) nounwind {
  %1 = uitofp i32 %a to float
  ret float %1
}

define i64 @fcvt_l_s(float %a) nounwind {
  %1 = fptosi float %a to i64
  ret i64 %1
}

define i64 @fcvt_lu_s(float %a) nounwind {
  %1 = fptoui float %a to i64
  ret i64 %1
}

define float @fcvt_s_l(i64 %a) nounwind {
  %1 = sitofp i64 %a to float
  ret float %1
}

define float @fcvt_s_lu(i64 %a) nounwind {
  %1 = uitofp i64 %a to float
  ret float %1
}

declare float @llvm.sqrt.f32(float)

define float @fsqrt_s(float %a) nounwind {
  %1 = call float @llvm.sqrt.f32(float %a)
  ret float %1
}

declare float @llvm.copysign.f32(float, float)

define float @fsgnj_s(float %a, float %b) nounwind {
  %1 = call float @llvm.copysign.f32(float %a, float %b)
  ret float %1
}

declare float @llvm.minnum.f32(float, float)

define float @fmin_s(float %a, float %b) nounwind {
  %1 = call float @llvm.minnum.f32(float %a, float %b)
  ret float %1
}

declare float @llvm.maxnum.f32(float, float)

define float @fmax_s(float %a, float %b) nounwind {
  %1 = call float @llvm.maxnum.f32(float %a, float %b)
  ret float %1
}


declare float @llvm.fma.f32(float, float, float)

define float @fmadd_s(float %a, float %b, float %c) nounwind {
  %1 = call float @llvm.fma.f32(float %a, float %b, float %c)
  ret float %1
}

define float @fmsub_s(float %a, float %b, float %c) nounwind {
  %c_ = fadd float 0.0, %c ; avoid negation using xor
  %negc = fsub float -0.0, %c_
  %1 = call float @llvm.fma.f32(float %a, float %b, float %negc)
  ret float %1
}

define float @fnmadd_s(float %a, float %b, float %c) nounwind {
  %a_ = fadd float 0.0, %a
  %c_ = fadd float 0.0, %c
  %nega = fsub float -0.0, %a_
  %negc = fsub float -0.0, %c_
  %1 = call float @llvm.fma.f32(float %nega, float %b, float %negc)
  ret float %1
}

define float @fnmsub_s(float %a, float %b, float %c) nounwind {
  %a_ = fadd float 0.0, %a
  %nega = fsub float -0.0, %a_
  %1 = call float @llvm.fma.f32(float %nega, float %b, float %c)
  ret float %1
}

declare float @llvm.ceil.f32(float)

define float @fceil_s(float %a) nounwind {
  %1 = call float @llvm.ceil.f32(float %a)
  ret float %1
}

declare float @llvm.cos.f32(float)

define float @fcos_s(float %a) nounwind {
  %1 = call float @llvm.cos.f32(float %a)
  ret float %1
}

declare float @llvm.sin.f32(float)

define float @fsin_s(float %a) nounwind {
  %1 = call float @llvm.sin.f32(float %a)
  ret float %1
}

declare float @llvm.exp.f32(float)

define float @fexp_s(float %a) nounwind {
  %1 = call float @llvm.exp.f32(float %a)
  ret float %1
}

declare float @llvm.exp2.f32(float)

define float @fexp2_s(float %a) nounwind {
  %1 = call float @llvm.exp2.f32(float %a)
  ret float %1
}

declare float @llvm.floor.f32(float)

define float @ffloor_s(float %a) nounwind {
  %1 = call float @llvm.floor.f32(float %a)
  ret float %1
}

declare float @llvm.flog.f32(float)

define float @fflog_s(float %a) nounwind {
  %1 = call float @llvm.flog.f32(float %a)
  ret float %1
}

declare float @llvm.flog2.f32(float)

define float @fflog2_s(float %a) nounwind {
  %1 = call float @llvm.flog2.f32(float %a)
  ret float %1
}

declare float @llvm.flog10.f32(float)

define float @fflog10_s(float %a) nounwind {
  %1 = call float @llvm.flog10.f32(float %a)
  ret float %1
}

declare float @llvm.fnearbyint.f32(float)

define float @fnearbyint_s(float %a) nounwind {
  %1 = call float @llvm.fnearbyint.f32(float %a)
  ret float %1
}

declare float @llvm.round.f32(float)

define float @fround_s(float %a) nounwind {
  %1 = call float @llvm.round.f32(float %a)
  ret float %1
}

declare float @llvm.fpround.f32(float)

define float @fpround_s(float %a) nounwind {
  %1 = call float @llvm.fpround.f32(float %a)
  ret float %1
}

declare float @llvm.rint.f32(float)

define float @frint_s(float %a) nounwind {
  %1 = call float @llvm.rint.f32(float %a)
  ret float %1
}

declare float @llvm.rem.f32(float)

define float @frem_s(float %a) nounwind {
  %1 = call float @llvm.rem.f32(float %a)
  ret float %1
}

declare float @llvm.pow.f32(float %Val, float %power)

define float @fpow_s(float %a, float %b) nounwind {
  %1 = call float @llvm.pow.f32(float %a, float %b)
  ret float %1
}

declare float @llvm.powi.f32(float %Val, i32 %power)

define float @fpowi_s(float %a, i32 %b) nounwind {
  %1 = call float @llvm.powi.f32(float %a, i32 %b)
  ret float %1
}

define double @fp_ext(float %a) nounwind {
  %conv = fpext float %a to double
  ret double %conv
}

define float @fp_trunc(double %a) nounwind {
  %conv = fptrunc double %a to float
  ret float %conv
}
